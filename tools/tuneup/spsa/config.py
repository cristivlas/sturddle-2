"""
Configuration dataclasses for the distributed SPSA tuner.

Two config files:
- Tuning config (tuning.json): shared session config, generated by genconfig.py
- Worker config (worker.json): per-machine settings, hand-edited
"""

import json
from dataclasses import dataclass, field, asdict
from typing import Any, Dict, Optional


@dataclass
class Parameter:
    """A single tunable engine parameter (Lakas-compatible format)."""
    name: str
    init: float
    lower: float
    upper: float
    type: str = "int"  # "int" or "float"

    def clamp(self, value: float) -> float:
        return max(self.lower, min(self.upper, value))

    def discretize(self, value: float) -> float:
        """Round to int if this is an integer parameter."""
        if self.type == "int":
            return round(value)
        return value

    def to_engine_value(self, value: float):
        """Convert internal float to engine-facing value."""
        v = self.clamp(value)
        if self.type == "int":
            return int(round(v))
        return v


@dataclass
class SPSAConfig:
    """
    SPSA hyperparameters.

    c is a fraction of each parameter's range (0.05 = perturb by 5% of range).
    a controls learning rate; effective step = a_k * gradient * range.
    """
    budget: int = 10000
    a: float = 0.5
    c: float = 0.05
    A_ratio: float = 0.1
    alpha: float = 0.602
    gamma: float = 0.101


@dataclass
class EngineConfig:
    """Engine settings (protocol and fixed UCI options)."""
    protocol: str = "uci"
    fixed_options: Dict[str, Any] = field(default_factory=dict)


@dataclass
class TuningConfig:
    """
    Main tuning session configuration (tuning.json).

    Contains only session-level settings shared across all workers:
    SPSA hyperparameters, parameter definitions, search control.

    Per-worker settings (engine path, opening book, games dir, logging)
    live in each worker's own worker.json.

    Search control: if `depth` is set, games use fixed depth search
    (cutechess-cli -each depth=N). Otherwise `time_control` is used
    (cutechess-cli -each tc=...).
    """
    engine: EngineConfig = field(default_factory=EngineConfig)
    time_control: str = "1+0.1"
    depth: Optional[int] = None
    games_per_iteration: int = 200
    output_dir: str = "./spsa_output"
    # Seconds for workers to wait before retrying when no work available
    retry_after: int = 5
    # Dashboard auto-refresh interval in seconds
    dashboard_refresh: int = 10
    # Max history entries sent to the dashboard (0 = unlimited)
    dashboard_history: int = 100
    work_stealing: bool = True
    bootstrap_chunk_size: int = 100
    spsa: SPSAConfig = field(default_factory=SPSAConfig)
    parameters: Dict[str, Parameter] = field(default_factory=dict)

    def max_iterations(self) -> int:
        return self.spsa.budget // self.games_per_iteration

    def to_json(self) -> str:
        d = {
            "engine": asdict(self.engine),
            "time_control": self.time_control,
            "depth": self.depth,
            "games_per_iteration": self.games_per_iteration,
            "retry_after": self.retry_after,
            "dashboard_refresh": self.dashboard_refresh,
            "output_dir": self.output_dir,
            "work_stealing": self.work_stealing,
            "bootstrap_chunk_size": self.bootstrap_chunk_size,
            "spsa": asdict(self.spsa),
            "parameters": {
                name: {
                    "init": p.init,
                    "lower": p.lower,
                    "upper": p.upper,
                    "type": p.type,
                }
                for name, p in self.parameters.items()
            },
        }
        return json.dumps(d, indent=2)

    @classmethod
    def from_json(cls, path: str) -> "TuningConfig":
        with open(path) as f:
            d = json.load(f)

        engine = EngineConfig(**d.get("engine", {}))
        spsa = SPSAConfig(**d.get("spsa", {}))

        parameters = {}
        for name, pdict in d.get("parameters", {}).items():
            parameters[name] = Parameter(name=name, **pdict)

        return cls(
            engine=engine,
            time_control=d.get("time_control", "1+0.1"),
            depth=d.get("depth"),
            games_per_iteration=d.get("games_per_iteration", 200),
            retry_after=d.get("retry_after", 5),
            dashboard_refresh=d.get("dashboard_refresh", 10),
            dashboard_history=d.get("dashboard_history", 100),
            output_dir=d.get("output_dir", "./spsa_output"),
            work_stealing=d.get("work_stealing", True),
            bootstrap_chunk_size=d.get("bootstrap_chunk_size", 100),
            spsa=spsa,
            parameters=parameters,
        )


@dataclass
class WorkerConfig:
    """
    Per-machine worker configuration (worker.json).

    All paths are local to the worker machine:
    engine binary, opening book, games output, log file.
    parameter_overrides allows overriding specific engine options per machine
    (e.g., SyzygyPath for different tablebase locations).
    """
    coordinator: str = "http://localhost:8080"
    engine: str = "./sturddle"
    cutechess_cli: str = "cutechess-cli"
    concurrency: int = 1
    opening_book: str = ""
    book_format: str = "pgn"
    book_depth: int = 8
    games_dir: str = "./games"
    log_file: str = "worker.log"
    max_chunk_size: int = 0  # max games per chunk (0 = unlimited)
    http_retry_timeout: int = 300  # seconds to retry on connection errors
    parameter_overrides: dict = field(default_factory=dict)
    # cutechess-cli overrides: tc, depth, etc. (not UCI options)
    cutechess_overrides: dict = field(default_factory=dict)

    @classmethod
    def from_json(cls, path: str) -> "WorkerConfig":
        with open(path) as f:
            d = json.load(f)
        return cls(**{k: v for k, v in d.items()
                      if k in cls.__dataclass_fields__})


@dataclass
class WorkItem:
    """A batch of games assigned to a worker."""
    iteration: int
    theta_plus: Dict[str, Any]   # param_name -> engine value
    theta_minus: Dict[str, Any]  # param_name -> engine value
    num_games: int
    chunk_id: str = ""           # unique chunk identifier

    def to_dict(self) -> dict:
        return asdict(self)

    @classmethod
    def from_dict(cls, d: dict) -> "WorkItem":
        return cls(**{k: v for k, v in d.items()
                      if k in cls.__dataclass_fields__})


@dataclass
class WorkResult:
    """Results reported by a worker for a batch (scores only, PGNs saved locally)."""
    iteration: int
    score_plus: float   # win rate for theta_plus side
    score_minus: float  # win rate for theta_minus side
    num_games: int
    chunk_id: str = ""  # echoed from WorkItem
    worker: str = ""    # worker hostname

    def to_dict(self) -> dict:
        return asdict(self)

    @classmethod
    def from_dict(cls, d: dict) -> "WorkResult":
        return cls(**{k: v for k, v in d.items()
                      if k in cls.__dataclass_fields__})
