"""
Configuration dataclasses for the distributed SPSA tuner.

Two config files:
- Tuning config (tuning.json): shared session config, generated by genconfig.py
- Worker config (worker.json): per-machine settings, hand-edited
"""

import json
from dataclasses import dataclass, field, asdict, MISSING
from typing import Any, Dict, Optional


@dataclass
class Parameter:
    """A single tunable engine parameter (Lakas-compatible format)."""
    name: str
    init: float
    lower: float
    upper: float
    type: str = "int"  # "int" or "float"
    # Original range for normalized parameters (where lower/upper are [-1, 1])
    original_lower: Optional[float] = None
    original_upper: Optional[float] = None

    @property
    def is_normalized(self) -> bool:
        return self.original_lower is not None

    def clamp(self, value: float) -> float:
        return max(self.lower, min(self.upper, value))

    def discretize(self, value: float) -> float:
        """Round to int if this is an integer parameter."""
        if self.type == "int":
            return round(value)
        return value

    def to_engine_value(self, value: float):
        """Convert internal float to engine-facing value."""
        v = self.clamp(value)
        if self.type == "int":
            return int(round(v))
        return v

    def denormalize(self, theta_val: float) -> int:
        """Convert theta value to engine-space integer.

        For normalized parameters, maps from [-1,1] to [original_lower, original_upper].
        For non-normalized parameters, rounds to int.
        """
        if self.is_normalized:
            lo, hi = self.original_lower, self.original_upper
            return int(round((theta_val + 1) * (hi - lo) / 2 + lo))
        return int(round(theta_val))


@dataclass
class SPSAConfig:
    """
    SPSA hyperparameters.

    c is a fraction of each parameter's range (0.05 = perturb by 5% of range).
    a controls learning rate; effective step = a_k * gradient * range.
    """
    budget: int = 10000
    a: float = 0.5
    c: float = 0.05
    A_ratio: float = 0.1
    alpha: float = 0.602
    gamma: float = 0.101


@dataclass
class EngineConfig:
    """Engine settings (protocol and fixed UCI options)."""
    protocol: str = "uci"
    fixed_options: Dict[str, Any] = field(default_factory=dict)


@dataclass
class TuningConfig:
    """
    Main tuning session configuration (tuning.json).

    Contains only session-level settings shared across all workers:
    SPSA hyperparameters, parameter definitions, search control.

    Per-worker settings (engine path, opening book, games dir, logging)
    live in each worker's own worker.json.

    Search control: if `depth` is set, games use fixed depth search
    (cutechess-cli -each depth=N). Otherwise `time_control` is used
    (cutechess-cli -each tc=...).
    """
    engine: EngineConfig = field(default_factory=EngineConfig)
    time_control: str = "1+0.1"
    depth: Optional[int] = None
    games_per_iteration: int = 200
    output_dir: str = "./spsa_output"
    # Seconds for workers to wait before retrying when no work available
    retry_after: int = 5
    # Dashboard auto-refresh interval in seconds
    dashboard_refresh: int = 10
    # Max history entries sent to the dashboard (0 = unlimited)
    dashboard_history: int = 100
    work_stealing: bool = True
    overdue_factor: float = 1.25
    worker_idle_timeout: float = 120.0
    chunk_timeout_factor: float = 2.5
    min_chunk_timeout: float = 60.0
    min_chunk_expected_duration: float = 60.0
    # Directory for static assets (favicon, etc.); empty = disabled
    static_dir: str = ""
    spsa: SPSAConfig = field(default_factory=SPSAConfig)
    parameters: Dict[str, Parameter] = field(default_factory=dict)

    def max_iterations(self) -> int:
        return self.spsa.budget // self.games_per_iteration

    def to_json(self) -> str:
        def _param_dict(p: Parameter) -> dict:
            d = {"init": p.init, "lower": p.lower, "upper": p.upper, "type": p.type}
            if p.original_lower is not None:
                d["original_lower"] = p.original_lower
            if p.original_upper is not None:
                d["original_upper"] = p.original_upper
            return d

        d = {
            "engine": asdict(self.engine),
            "time_control": self.time_control,
            "depth": self.depth,
            "games_per_iteration": self.games_per_iteration,
            "retry_after": self.retry_after,
            "dashboard_refresh": self.dashboard_refresh,
            "dashboard_history": self.dashboard_history,
            "output_dir": self.output_dir,
            "work_stealing": self.work_stealing,
            "overdue_factor": self.overdue_factor,
            "worker_idle_timeout": self.worker_idle_timeout,
            "chunk_timeout_factor": self.chunk_timeout_factor,
            "min_chunk_timeout": self.min_chunk_timeout,
            "min_chunk_expected_duration": self.min_chunk_expected_duration,
            "static_dir": self.static_dir,
            "spsa": asdict(self.spsa),
            "parameters": {
                name: _param_dict(p) for name, p in self.parameters.items()
            },
        }
        # Omit None values for cleaner output
        d = {k: v for k, v in d.items() if v is not None}
        return json.dumps(d, indent=2)

    @classmethod
    def from_json(cls, path: str) -> "TuningConfig":
        with open(path) as f:
            d = json.load(f)

        engine = EngineConfig(**d.get("engine", {}))
        spsa = SPSAConfig(**d.get("spsa", {}))

        parameters = {}
        for name, pdict in d.get("parameters", {}).items():
            parameters[name] = Parameter(name=name, **pdict)

        # Pull scalar fields from JSON, falling back to dataclass defaults
        fields = cls.__dataclass_fields__
        skip = {"engine", "spsa", "parameters"}
        kwargs = {}
        for name, f in fields.items():
            if name in skip:
                continue
            default = None if f.default is MISSING else f.default
            kwargs[name] = d.get(name, default)

        return cls(engine=engine, spsa=spsa, parameters=parameters, **kwargs)


@dataclass
class WorkerConfig:
    """
    Per-machine worker configuration (worker.json).

    All paths are local to the worker machine:
    engine binary, opening book, games output, log file.
    parameter_overrides allows overriding specific engine options per machine
    (e.g., SyzygyPath for different tablebase locations).
    """
    name: str = ""  # worker identity; defaults to hostname if empty
    coordinator: str = "http://localhost:8080"
    engine: str = "./sturddle"
    cutechess_cli: str = "cutechess-cli"
    concurrency: int = 1
    opening_book: str = ""
    book_format: str = "pgn"
    book_depth: int = 8
    games_dir: str = "./games"
    log_file: str = "worker.log"
    max_chunk_size: int = 0  # hard cap on games per chunk (0 = unlimited)
    max_rounds_per_chunk: int = 10  # cap = concurrency * this * 2 (0 = unlimited)
    http_retry_timeout: int = 300  # seconds to retry on connection errors
    parameter_overrides: dict = field(default_factory=dict)
    # cutechess-cli overrides: tc, depth, etc. (not UCI options)
    cutechess_overrides: dict = field(default_factory=dict)

    @classmethod
    def from_json(cls, path: str) -> "WorkerConfig":
        with open(path) as f:
            d = json.load(f)
        return cls(**{k: v for k, v in d.items()
                      if k in cls.__dataclass_fields__})


@dataclass
class WorkItem:
    """A batch of games assigned to a worker."""
    iteration: int
    theta_plus: Dict[str, Any]   # param_name -> engine value
    theta_minus: Dict[str, Any]  # param_name -> engine value
    num_games: int
    chunk_id: str = ""           # unique chunk identifier

    def to_dict(self) -> dict:
        return asdict(self)

    @classmethod
    def from_dict(cls, d: dict) -> "WorkItem":
        return cls(**{k: v for k, v in d.items()
                      if k in cls.__dataclass_fields__})


@dataclass
class WorkResult:
    """Results reported by a worker for a batch (game counts, PGNs saved locally)."""
    iteration: int
    wins: int           # games won by theta_plus side
    draws: int          # drawn games
    losses: int         # games lost by theta_plus side (= won by theta_minus)
    num_games: int      # actual games completed
    chunk_id: str = ""  # echoed from WorkItem
    worker: str = ""    # worker hostname

    def to_dict(self) -> dict:
        return asdict(self)

    @classmethod
    def from_dict(cls, d: dict) -> "WorkResult":
        return cls(**{k: v for k, v in d.items()
                      if k in cls.__dataclass_fields__})
